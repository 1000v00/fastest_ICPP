/***********************************************************************/
/*                                                                     */
/*  FILE        :REMON.c                                               */
/*  DATE        :Tue, Aug 09, 2022                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :62P                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

/* Mutual Exclusion Type */
//#define MUTUAL_EX // DI/EI
#define REMON_SEM	// REMON Semaphore

/* インクルードファイル */
#include "sfr62p.h"			/* OAKS16用定義ファイル */
#include "REMON.h"
#include "icb.h"
#include "task.h"
#include "dispatcher.h"
#include "semaphore.h"

/* プロトタイプ宣言 */
void	main(void);			/* メイン関数	*/

void	ta0int();			/* タイマーA0割込み(中間優先度) */
#pragma	INTERRUPT	ta0int

void	ta1int();			/* タイマーA1割込み(最高優先度) */
#pragma	INTERRUPT	ta1int

void task0(void);
void task1(void);
void task2(void);
void task3(void);
void task4(void);
void task5(void);
void task6(void);
void task7(void);

/* マクロ定義 */
#define PORTIN	0x00		/* ポート方向レジスタを入力に設定する為のデータ */
#define PORTOUT	0xff		/* ポート方向レジスタを出力に設定する為のデータ */

/* 初回起動タイミング および 起動周期（単位ms）適時変更する */
//#define TA0_ms	1200	/* タイマA0 (1200ms)カウンタ値 */
//#define TA1_ms	1100	/* タイマA1 (1100ms)カウンタ値 */
#define TA0_ms	7000		/* タイマA0 (7000ms)カウンタ値 */
#define TA1_ms	5000		/* タイマA1 (5000ms)カウンタ値 */


/* 中間優先度タスク */
#define	cnt_ta0	(24000-1)	/* タイマA0の1msのカウンタ値(アンダーフロー発生時に割り込み発生) */
#define	cnt_ms_ta0	TA0_ms	

/* 高優先度タスク */
#define	cnt_ta1	(24000-1)	/* タイマA1の1msのカウンタ値(アンダーフロー発生時に割り込み発生) */
#define	cnt_ms_ta1 TA1_ms


/* 変数宣言 */
static	unsigned int	ta0_mscnt;		/* ta0用カウンタ用変数 */
static	unsigned int	ta1_mscnt;		/* ta1用カウンタ用変数 */


/* ダミー処理用関数型マクロ定義 */
#define dummy_work(a, b, c, d, count1, count2, num, port1, port2, value) \
	for((count1) = (num) ; (count1) ; (count1)--){			\
		for((count2) = (num) ; (count2) ; (count2)--){		\
			(d) = (c) / (b);				\
			(d) = (d) / (a);				\
			_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
			port1 = (value);				\
			_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
			port2 = (value);				\
	 		_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
			_asm("\tnop");					\
		}									\
	}

///////////////////////////////////////////////

void main(void)
{
	volatile unsigned long cnt;
	volatile static unsigned int ad_fin = 0;
	unsigned char led_data;

	/* dummy_work()用変数 */
	volatile long a = 3;
	volatile long b = 7;
	volatile long c = 21;
	volatile long d;
	volatile long i, j;	
						
	_asm( "\tFCLR	I");			/* 割り込み禁止						*/

	p0 = 0x00;						/* ポート1データ初期化				*/
	pd0 = PORTOUT;					/* ポート1出力設定					*/
		
	p1 = 0x00;						/* LED用ポート1データ初期化			*/
	pd1 = PORTOUT;					/* LED用ポート1出力設定				*/
	
	p2 = 0x00;						/* ロジックアナライザ用ポート2データ初期化	*/
	pd2 = PORTOUT;					/* ロジックアナライザ用ポート2出力設定		*/

	ta0_mscnt = cnt_ms_ta0;			/* ta0用カウンタ初期化 */
	ta1_mscnt = cnt_ms_ta1;			/* ta1用カウンタ初期化 */

	udf = 0x00;						/* ta0-ta4タイマ ダウンカウント設定	*/	
	
	ta0mr = 0x00;					/* タイマモード	クロック：f1		*/
	ta0 = cnt_ta0;					/* タイマ値の初期化					*/
	ta0ic = 0x03;					/* 割り込みレベルの設定				*/	
	
	ta1mr = 0x00;					/* タイマモード	クロック：f1		*/
	ta1 = cnt_ta1;					/* タイマ値の初期化					*/
	ta1ic = 0x05;					/* 割り込みレベルの設定				*/
	
	ini_tsk();
	ini_sem();

	cre_tsk((unsigned short)0, (unsigned long)task0);
	cre_tsk((unsigned short)1, (unsigned long)task1);
	cre_tsk((unsigned short)2, (unsigned long)task2);
	cre_tsk((unsigned short)3, (unsigned long)task3);
	cre_tsk((unsigned short)4, (unsigned long)task4);
	cre_tsk((unsigned short)5, (unsigned long)task5);
	cre_tsk((unsigned short)6, (unsigned long)task6);
	cre_tsk((unsigned short)7, (unsigned long)task7);

	_asm( "\tFSET	I");			/* 割り込み許可						*/
	
	sta_tsk((unsigned short)6);

	for (;;) {		// ここへは来ない（デバッグ用）
		unsigned int i;
		p0 ^= 0x01;
		for (i = 0xFFFFF; i; --i);
	}
}

void task0(void) /* Highest Priority */
{
	volatile unsigned long cnt;
	unsigned char led_data[] = {0x18, 0x3c, 0x7e, 0xff, ~0x18, ~0x3c, ~0x7e, ~0xff};
	int led_count;
	
	/* dummy_work()用変数 */
	volatile long a = 3;
	volatile long b = 7;
	volatile long c = 21;
	volatile long d;
	long i, j;
	
	for(led_count = 0; (led_count + 1) & 0x07 ; led_count++) {
		dummy_work(a, b, c, d, i, j, 100, p1, p2, led_data[led_count & 0x07]);	/* 排他制御不要 */
	}	
	ext_tsk();	
}

void task1(void) /* Middle Priority */
{
	unsigned char led_data;
	
	/* dummy_work()用変数 */
	volatile long a = 3;
	volatile long b = 7;
	volatile long c = 21;
	volatile long d;
	volatile long i, j;	
	
	dummy_work(a, b, c, d, i, j, 120, p1, p2, 0xa5);	/* 排他制御不要 */
	
#ifdef MUTUAL_EX
	_asm( "\tFCLR	I");		/* 割り込み禁止 */
#else
#ifdef REMON_SEM
		wai_sem((unsigned short)3);
#endif
#endif

	for(led_data = 0x01; led_data ; led_data <<= 0x01) {
		dummy_work(a, b, c, d, i, j, 120, p1, p2, led_data);	/* 排他制御必要 */
	}
		
#ifdef MUTUAL_EX
		_asm( "\tFSET	I");		/* 割り込み許可	*/
#else
#ifdef REMON_SEM
		sig_sem((unsigned short)3);
#endif
#endif

	dummy_work(a, b, c, d, i, j, 120, p1, p2, 0x5a);	/* 排他制御不要 */
	ext_tsk();	
}


void task6(void) /* Lowest Priority */
{
	unsigned char led_data;

	/* dummy_work()用変数 */
	volatile long a = 3;
	volatile long b = 7;
	volatile long c = 21;
	volatile long d;
	volatile long i, j;

	tabsr = 0x03;					/* ta0,ta1 カウント開始				*/
		
	for(;;) {
		dummy_work(a, b, c, d, i, j, 200, p1, p2, 0x0f);	/* 排他制御不要 */	
			
#ifdef MUTUAL_EX
		_asm( "\tFCLR	I");		/* 割り込み禁止 */
#else
#ifdef REMON_SEM
		wai_sem((unsigned short)3);
#endif
#endif

		for(led_data = 0x80; led_data ; led_data >>= 0x01) {
			p1 = led_data, p2 = led_data;
			dummy_work(a, b, c, d, i, j, 170, p1, p2, led_data);	/* 排他制御必要 */
		}
		
#ifdef MUTUAL_EX
		_asm( "\tFSET	I");		/* 割り込み許可	*/
#else
#ifdef REMON_SEM
		sig_sem((unsigned short)3);
#endif
#endif
		dummy_work(a, b, c, d, i, j, 200, p1, p2, 0xf0);	/* 排他制御不要 */
	} /* forever */
		
	ext_tsk(); /* Never come here, Optimiser delete this code */
}





//////////////////////////////
//タイマーA0割り込み 低優先度
void	ta0int()
{	
//	_asm( "\tFSET	I");	/* 多重割り込み許可		*/
	
	ta0_mscnt--;				/* 1秒用カウンタ-1		*/
	if(ta0_mscnt==0){			/* 1150ms経過			*/
//		tabsr &= ~0x01;			/* ta0 timer stop		*/
		sta_tsk((unsigned short)1);
		ta0_mscnt = cnt_ms_ta0;	/* 1150ms用カウンタ初期化	*/
	}
}


//////////////////////////////
//タイマーA1割り込み 高優先度
void	ta1int()
{
//	_asm( "\tFSET	I");	/* 多重割り込み許可		*/
	
	ta1_mscnt--;				/* 1秒用カウンタ-1		*/
	if(ta1_mscnt==0){		/* 1149m経過				*/
//		tabsr &= ~0x02;		/* ta1 timer stop		*/
		sta_tsk((unsigned short)0);	
		ta1_mscnt = cnt_ms_ta1;	/* 1149ms用カウンタ初期化	*/
	}	
}

void task2(void)
{
	p1 = 2;
	p2 = 2;
	ext_tsk();
}

void task3(void)
{
	p1 = 3;
	p2 = 3;
	ext_tsk();
}

void task4(void)
{
	p1 = 4;
	p2 = 4;
	ext_tsk();
}

void task5(void)
{
	p1 = 5;
	p2 = 5;
	ext_tsk();
}

void task7(void)
{
	p1 = 6;
	p2 = 6;
	ext_tsk();
}


void int0(void)
{
	sta_tsk(0);
}

void int1(void)
{
	sta_tsk(1);
}